# make fzf use rg and include hidden files
export FZF_DEFAULT_COMMAND='rg --files --no-ignore-vcs --hidden -g "!{node_modules/*,.git/*}"'

alias fzf-default='fzf --bind "ctrl-j:preview-down,ctrl-k:preview-up,ctrl-d:preview-page-down,ctrl-u:preview-page-up"' 

mkcd(){
    mkdir $1 && cd $1
}

# create document in vidoc folder with scratch functionality, naming, and stdin support 
doc(){      
    local target_path=$HOME/Documents/vdoc
    if [ -z "$1" ]; then
        if (( $# == 0 )) ; then
            local p=$(vdoc --target-path=$target_path  )
            nvim $p
        else
            local p=$(vdoc --target-path=$target_path < /dev/stdin)
            nvim $p
        fi

    else 
        if (( $# == 0 )) ; then
            local p=$(vdoc --target-path=$target_path --file-name=$1)
            nvim $p
        else
            local p=$(vdoc --target-path=$target_path --file-name=$1 < /dev/stdin)
            nvim $p
        fi
    fi
}

# pretty print csv file
csvcat(){
    column -s, -t < $1 | less -#2 -N -S
}

fif(){
    local RG_PREFIX='rg --column --line-number --no-heading --color=always --smart-case  -g "!{node_modules/*,.git/*}"'
    local search_path="."
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -a)
                RG_PREFIX='rg --column --line-number --no-heading --color=always --smart-case --no-ignore --hidden -g "!{node_modules/*,.git/*}"'
                shift
                ;;
            *)
                if [[ -d "$1" ]]; then
                    search_path="$1"
                    shift
                else
                    break
                fi
                ;;
        esac
    done
    
    local INITIAL_QUERY="${*:-}"
    local fzf_result=$(FZF_DEFAULT_COMMAND="$RG_PREFIX $(printf %q "$INITIAL_QUERY") $search_path" \
    fzf --ansi \
          --disabled \
          --query "$INITIAL_QUERY" \
          --bind "change:reload:sleep 0.1; $RG_PREFIX {q} $search_path || true" \
          --delimiter : \
          --preview 'bat --color=always {1} --highlight-line {2}' \
          --preview-window 'up,60%,border-bottom,+{2}+3/3,~3') 

    local result=${fzf_result%%:*}
    local line_no=$(echo $fzf_result | cut -d: -f2)

    if [ "x$result" != "x" ]; then
        nvim +$line_no $result
    fi
}


##
# fdir: fuzzy-find directories
# Usage: 
#   fdir [-a] [path]
#     -a      Show hidden directories as well
#     path    Optional path argument to limit search
##
fdir() {
  emulate -L zsh

  # Default options
  local hidden=false
  local preview='exa {} -T -L 1 --long --git --colour=always --icons --no-permissions \
                 --no-time --no-user --no-filesize --group-directories-first --sort=extension'

  # Parse flags
  local opt
  while getopts ":a" opt; do
    case $opt in
      a)
        hidden=true
        ;;
      \?)
        echo "Invalid option: -$OPTARG" >&2
        return 1
        ;;
    esac
  done
  shift $((OPTIND - 1))

  # If there's a positional argument left, treat it as the path argument
  local patharg=$1

  # Construct the fd command
  local fd_cmd="fd --type directory"
  if [[ $hidden = true ]]; then
    fd_cmd="fd -u --type directory"
  fi

  # If a path argument was given, append it
  if [[ -n "$patharg" ]]; then
    # Note: quoting carefully so expansions happen correctly
    fd_cmd+=" . \"$patharg\""
  fi

  local preview_label='[ enter = cd, ctrl+o = nvim, ctrl+s = ff, ctrl+f = fif ]'
  local preview_window='up,85%,border-bottom,+{2}+3/3,~3'
  # Run fd -> fzf with preview, capturing keypress + selection
  local output
  output=$(eval "$fd_cmd" | \
    fzf-default --preview "$preview" \
      --preview-window $preview_window \
      --expect ctrl-o,ctrl-r,ctrl-s,ctrl-f,enter \
      --preview-label $preview_label \
      )

  # If user presses <esc> or there's no selection, exit
  if [[ -z "$output" ]]; then
    return
  fi

  # Parse out the key and the selected directory
  local key val
  key=$(echo "$output" | head -1)
  val=$(echo "$output" | tail -1)

  # Act on the key pressed
  case "$key" in
    enter)
      [[ -n "$val" ]] && cd "$val"
      ;;
    ctrl-o)
      [[ -n "$val" ]] && nvim "$val"
      ;;
    ctrl-r)
      [[ -n "$val" ]] && fdir "$val"
      ;;
    ctrl-s)
      [[ -n "$val" ]] && ff "$val"
      ;;
    ctrl-f)
      [[ -n "$val" ]] && fif "$val"
      ;;
  esac
}

##
# ff: fuzzy-find files
# Usage:
#   ff [-a] [path]
#     -a      Show hidden files as well
#     path    Optional path argument to limit search
##
ff() {
  emulate -L zsh

  # Default options
  local hidden=false
  local preview="bat --color=always --style=numbers --line-range :500 {}"

  # Parse flags
  local opt
  while getopts ":a" opt; do
    case $opt in
      a)
        hidden=true
        ;;
      \?)
        echo "Invalid option: -$OPTARG" >&2
        return 1
        ;;
    esac
  done
  shift $((OPTIND - 1))

  # If there's a positional argument left, treat it as the path argument
  local patharg=$1

  # Construct the fd command
  local fd_cmd="fd --type file"
  if [[ $hidden = true ]]; then
    fd_cmd="fd -u --type file"
  fi

  # If a path argument was given, append it
  if [[ -n "$patharg" ]]; then
    fd_cmd+=" . \"$patharg\""
  fi

  local preview_label='[ enter = nvim, ctrl+o = cd, ctrl+s = fdir, ctrl+f = fif ]'
  # Run fd -> fzf
  local output
  output=$(eval "$fd_cmd" | \
    fzf-default \
      --expect ctrl-o,ctrl-s,ctrl-f,enter \
      --preview "$preview" \
      --preview-window 'up,60%,border-bottom,+{2}+3/3,~3' \
      --preview-label $preview_label )

  # If user presses <esc> or there's no selection, exit
  if [[ -z "$output" ]]; then
    return
  fi

  # Parse out the key and the selected file
  local key val
  key=$(echo "$output" | head -1)
  val=$(echo "$output" | tail -1)

  # Act on the key pressed
  case "$key" in
    enter)
      [[ -n "$val" ]] && nvim "$val"
      ;;
    ctrl-o)
      # Example: opens the parent directory in nvim? Or just cd?
      # Adjust to your liking
      [[ -n "$val" ]] && cd "$(dirname "$val")"
      ;;
    ctrl-s)
      [[ -n "$val" ]] && fdir "$(dirname "$val")"
      ;;
    ctrl-f)
      [[ -n "$val" ]] && fif "$(dirname "$val")"
      ;;
  esac
}


fic(){
  local preview="exa {} -T -L 1 --long --git --colour=always --icons --no-permissions --no-time --no-user --no-filesize --group-directories-first --sort=extension"
  local result=$(fd -u -d 1 --type directory . $HOME/Code | fzf-default --preview $preview)
  [[ -n "$result" ]] && cd "$result"
}


# search unique file history and copy output to terminal 
fh(){
  local result=$(history | cut -c 8- | sort | uniq | fzf-default --tac | sed -E 's/ *[0-9]*\*? *//' | sed -E 's/\\/\\\\/g') 
  [[ -n "$result" ]] && print -z "$result"
}

# Find program: search through executable command in path - preview with tldr page
fp(){
    local preview_window='up,85%,border-bottom,+{2}+3/3,~3'
    local p=$(compgen -c | sed '/^_/d' | sort |  \
      fzf-default --preview "tldr {}" \
      --bind "?:preview:man {}" \
      --preview-label '[ enter = print cmd, ? = preview man, ctrl-v = open man ]' \
      --preview-window $preview_window \
      --expect enter,ctrl-v)

    local key val
    key=$(echo "$p" | head -1)
    val=$(echo "$p" | tail -1)

    case "$key" in 
      enter) 
        [[ -n "$val" ]] && print -z "$val"
        ;;
      ctrl-v) 
        [[ -n "$val" ]] && man "$val"
        ;;
    esac
    
}

# search through processes and kill the selected one
# TODO: make output prettier (shorter)
fkill() {
    local pid 
    if [ "$UID" != "0" ]; then
        pid=$(ps -f -u $UID | sed 1d | fzf -m | awk '{print $2}')
    else
        pid=$(ps -ef | sed 1d | fzf -m | awk '{print $2}')
    fi  

    if [ "x$pid" != "x" ]
    then
        echo $pid | xargs kill -${1:-9}
    fi  
}


lzcommit() {
    if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        echo "You are not inside a Git repository."
        return
    fi

    if [ -z "$(git status --porcelain)" ]; then
        echo "No changes detected in the Git repository."
        return
    fi

    local msg=$(git -c pager.diff='less -R' diff | aichat --model "openai:gpt-3.5-turbo" 'Write me a succinct git commit messsage for these changes.' )
    echo $msg
    read -q "response?Do you want to commit? (y/n):"
    echo ""
    if [[ $response == "y" ]]; then
        git commit -am "$msg"
        echo "Committed!"
    elif [[ $response == "n" ]]; then
        echo "Not committed"
    else
        echo "Invalid response."
    fi
}

nix-installed() {
  local result=$(nix-store -q --requisites /run/current-system | fzf)
  [[ -n "$result" ]] && cd "$result"
}

fpath(){
    local dir=$(tr ':' '\n' <<< "$PATH" | fzf-default --preview 'exa -1 {}')
    [[ -n $dir ]] && cd "$dir"
}

fenv(){
    env | cut -d '=' -f 1 | fzf-default --preview 'printenv {}'
}

mkcode(){
    if [ -z "$1" ]; then
        echo "You must specify a directory name."
        return 1
    fi

    mkdir -p "$HOME/Code/$1"
    cd "$HOME/Code/$1"
}

function gi() {
    local templates=$(curl -sL "https://www.toptal.com/developers/gitignore/api/list" | tr "," "\n")
    local selections=$(echo "$templates" | fzf-default -m --height=40% --preview="curl -sL https://www.toptal.com/developers/gitignore/api/{}")
    
    if [[ -n "$selections" ]]; then
        if [[ -f ".gitignore" ]]; then
            echo "" >> .gitignore  # Ensure there is a newline at the end of the existing file
            echo "# Added on $(date)" >> .gitignore  # Optionally, add a comment indicating when new sections were added
        fi
        echo "$selections" | xargs -I {} curl -sL "https://www.toptal.com/developers/gitignore/api/{}" >> .gitignore
        echo ".gitignore file updated successfully."
    else
        echo "No selections made. No changes to .gitignore."
    fi
}


